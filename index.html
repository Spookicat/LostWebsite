<!DOCTYPE html>
<html lang="en">
<head>
    <title>I was lost once too</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Open+Sans">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>

    
    <script src="js/three.js"></script>
    <script src="js/gsap.min.js"></script>
    <script src="js/Tone.js"></script>

    <div id="parent">
        <form id="mysteryform" autocomplete="off">
            <input id="mysteriousbox" type="text" />
        </form>
    </div>

    <script>
        var camera, scene, renderer;
        var submitting;
        var displayText;

        var funTones = ["C3","D3","E3","F3","G3","A3","B3"];
        var scareTones =["C#2","D#2","F#2","G#1","A#1"];

        const panner = new Tone.Panner3D();
        panner.set({panningModel: "HRTF"});

        const funSynth = new Tone.Synth();
        const scareSynth = new Tone.DuoSynth();

        // funSynth effects
        //const autoPanner = new Tone.AutoPanner("2n").start();
        const feedbackDelay = new Tone.FeedbackDelay(.475, 0.5);
        const reverb = new Tone.Reverb(4.5);

        // scareSynth effects
        const crusher = new Tone.BitCrusher(4);
        const distortion = new Tone.Distortion(0.1);
        const scareVerb = new Tone.JCReverb(0.8);
        const EQ = new Tone.EQ3(-3, -5, -10);


        funSynth.envelope.set({attack: 0.1})
        feedbackDelay.set( {wet: 0.5} );
        reverb.set( {wet: 0.7} );
        
        scareSynth.set( {volume : -25, detune: -3, voice1: {detune: -5}, voice2: {detune: -9}} );
        
        funSynth.chain(feedbackDelay, reverb, panner, Tone.Destination);
        scareSynth.chain(crusher, distortion, scareVerb, EQ, Tone.Destination);

        function processText(e)
        {
            if(e.preventDefault) e.preventDefault();

            var phrase = document.getElementById("mysteriousbox").value.toLowerCase();
            var form = this;
            var font = 'fonts/Oswald_Medium.typeface.json';
            var scary = false;
            var text;

            if(!submitting){
                switch(phrase){
                    case "spookicat":
                        displayText = "You've heard it too?";
                        submitting = true;
                        break;
                    case "please kill me":
                        displayText = "Okay.";
                        submitting = true;
                        scary = true;
                        break;
                    default:
                        displayText = "You're lost aren't you?"
                        submitting = true;
                }
                displayResponse(font, scary);
            }
            return false;
        }

        var form = document.getElementById('mysteryform');

        if(form.attachEvent){
            form.attachEvent("submit", processText);
        }   else{
            form.addEventListener("submit", processText);
        }

        function displayResponse( textFont, scary )
        {
            var loader = new THREE.FontLoader();
            loader.load(textFont, function (font) {

            var textGeo = new THREE.TextGeometry(displayText, {
                font: font,
                size: 10,
                height: 1,
                curveSegments: 12,
            });
            
            textGeo.computeBoundingBox();
			//textGeo.computeVertexNormals();

            var centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

            var textMat = new THREE.MeshPhongMaterial({color: 0xFFFFFF, emissive: 0x2a2a2a, emissiveIntensity: .5});
            var textMesh = new THREE.Mesh(textGeo, textMat);
            textMesh.name = "text";
            textMesh.position.z = -200;
            textMesh.position.x = centerOffset;
            textMesh.position.y = -28;

            textMesh.rotation.x = 0;
			textMesh.rotation.y = Math.PI * 2;
            textMesh.material.transparent = true;
            textMesh.material.opacity = 1;

            scene.add(textMesh);

            animateText(textMesh, scary);
        });
        }

        function animateText(textMesh, scary)
        {
            var newX = Math.floor(Math.random() * 400) - 200;
            var newY = Math.floor(Math.random() * 80);
            var newZ = Math.floor(Math.random() * 200) - 400;
            var duration = 1;

            if (scary)
            {
                playScareSound();
            }
            else
            {
                playFunSound(newX, newY, newZ);
            }

            var tl = gsap.timeline({onComplete: removeEntity, onCompleteParams:["text"]});
            tl.from(textMesh.material, duration+1, {opacity: 0, ease:"slow"});
            tl.from(textMesh.position, duration, {x: newX, z: newZ, ease:"power2"},0);
            tl.from(textMesh.position, duration-0.5, {y: newY, ease:"power1"},0);

            var n = displayText.length/10;
            tl.to(textMesh.material, 1, {opacity:0}), '+=${n}';
        }

        function removeEntity(object)
        {
            var selectedObject = scene.getObjectByName(object);
            scene.remove( selectedObject );
            submitting = false;
            animate();
        }

        function playFunSound(x, y, z)
        {
            panner.setPosition(x/100,1,0.5)
            funSynth.triggerAttackRelease(funTones[Math.floor(Math.random() * 7)], "16n");
        }

        function playScareSound()
        {
            scareSynth.triggerAttackRelease(scareTones[Math.floor(Math.random() * 5)], "3n");
        }

        function init()
        {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            
            var light = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(light);
            
            var light2 = new THREE.PointLight(0xdddddd, 0.5);
            light2.position.y = 250;
            scene.add(light2);

            submitting = false;
            
            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;

                camera.updateProjectionMatrix();
            })
        }

        var animate = function () {
            requestAnimationFrame( animate );

            render();
        }

        function render() {
            renderer.render(scene, camera);
        }
    
        init();
        animate();
    </script>

</body>
</html>