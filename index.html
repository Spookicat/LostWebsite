<!DOCTYPE html>
<html lang="en">
<head>
    <title>I was lost once too</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Open+Sans">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>

    
    <script src="lib/three.js"></script>
    <script src="lib/gsap.min.js"></script>
    <script src="lib/Tone.js"></script>
    <script src="lib/postprocessing/EffectComposer.js"></script>
    <script src="lib/postprocessing/MaskPass.js"></script>
    <script src="lib/postprocessing/RenderPass.js"></script>
    <script src="lib/postprocessing/ShaderPass.js"></script>
    <script src="lib/shaders/CopyShader.js"></script>
    <script src="lib/shaders/FilmShader.js"></script>
    <script src="lib/shaders/RGBShiftShader.js"></script>

    <div id="parent">
        <form id="mysteryform" autocomplete="off">
            <input id="mysteriousbox" type="text" />
        </form>
    </div>

    <script>
        var camera, scene, renderer;
        var shaderTime = 0;
        var rgbParams, rgbPass;
        var filmParams, filmPass;
        var renderPass, copyPass;
        var submitting;
        var displayText;

        var funTones = ["C3","D3","E3","F3","G3","A3","B3"];
        var scareTones =["C#2","D#2","F#2","G#1","A#1"];

        //const panner = new Tone.Panner3D();
        //panner.set({panningModel: "HRTF"});

        const funSynth = new Tone.Synth();
        const scareSynth = new Tone.DuoSynth();

        // funSynth effects
        //const autoPanner = new Tone.AutoPanner("2n").start();
        const feedbackDelay = new Tone.FeedbackDelay(.475, 0.5);
        const reverb = new Tone.Reverb(4.5);

        // scareSynth effects
        const crusher = new Tone.BitCrusher(4);
        const distortion = new Tone.Distortion(0.1);
        const scareVerb = new Tone.JCReverb(0.8);
        const EQ = new Tone.EQ3(-3, -5, -10);


        funSynth.envelope.set({attack: 0.1})
        feedbackDelay.set( {wet: 0.5} );
        reverb.set( {wet: 0.7} );
        
        scareSynth.set( {volume : -20, detune: -3, voice1: {detune: -5}, voice2: {detune: -9}} );
        
        funSynth.chain(feedbackDelay, reverb, Tone.Destination);
        scareSynth.chain(crusher, distortion, scareVerb, EQ, Tone.Destination);

        function processText(e)
        {
            if(Tone.context.state != 'running'){
                Tone.start();
            }
            if(e.preventDefault) e.preventDefault();

            var phrase = document.getElementById("mysteriousbox").value.toLowerCase();
            var form = this;
            var font = 'fonts/Oswald_Medium.typeface.json';
            var scary = false;
            var text;

            if(!submitting){
                switch(phrase){
                    case "spookicat":
                        displayText = "You've heard it too?";
                        submitting = true;
                        break;
                    case "please kill me":
                        font = 'fonts/DOS_Win_Regular.typeface.json';
                        displayText = "Okay.";
                        submitting = true;
                        scary = true;
                        break;
                    default:
                        displayText = "You're lost aren't you?"
                        submitting = true;
                }
                displayResponse(font, scary);
            }
            return false;
        }

        var form = document.getElementById('mysteryform');

        if(form.attachEvent){
            form.attachEvent("submit", processText);
        }   else{
            form.addEventListener("submit", processText);
        }

        function displayResponse( textFont, scary )
        {
            var loader = new THREE.FontLoader();
            loader.load(textFont, function (font) {

                var textGeo = new THREE.TextGeometry(displayText, {
                    font: font,
                    size: 10,
                    height: 1,
                    curveSegments: 12,
                });
                
                textGeo.computeBoundingBox();
                //textGeo.computeVertexNormals();

                var centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
                var textMat;

                if(scary)
                {
                    textMat = new THREE.MeshPhongMaterial({color: 0xFFFF00, emissive: 0x2a2a2a, emissiveIntensity: .5});
                }
                else{
                    textMat = new THREE.MeshPhongMaterial({color: 0xFFFFFF, emissive: 0x2a2a2a, emissiveIntensity: .5});
                }

                var textMesh = new THREE.Mesh(textGeo, textMat);
                textMesh.name = "text";
                textMesh.position.z = -200;
                textMesh.position.x = centerOffset;
                textMesh.position.y = -28;

                textMesh.rotation.x = 0;
                textMesh.rotation.y = Math.PI * 2;
                textMesh.material.transparent = true;
                textMesh.material.opacity = 1;

                scene.add(textMesh);

                animateText(textMesh, scary);
            });
        }

        function animateText(textMesh, scary)
        {
            var newX = Math.floor(Math.random() * 400) - 200;
            var newY = Math.floor(Math.random() * 80);
            var newZ = Math.floor(Math.random() * 200) - 400;
            var duration = 1;

            if (scary)
            {
                playScareSound();
            }
            else
            {
                playFunSound(newX, newY, newZ);
            }

            var tl = gsap.timeline({onComplete: removeEntity, onCompleteParams:["text"]});
            tl.from(textMesh.material, duration+1, {opacity: 0, ease:"slow"});
            tl.from(textMesh.position, duration, {x: newX, z: newZ, ease:"power2"},0);
            tl.from(textMesh.position, duration-0.5, {y: newY, ease:"power1"},0);

            var n = displayText.length/10;
            tl.to(textMesh.material, 1, {opacity:0}), '+=${n}';
        }

        function removeEntity(object)
        {
            var selectedObject = scene.getObjectByName(object);
            scene.remove( selectedObject );
            submitting = false;
            animate();
        }

        function playFunSound(x, y, z)
        {
            funSynth.triggerAttackRelease(funTones[Math.floor(Math.random() * 7)], "16n");
        }

        function playScareSound()
        {
            scareSynth.triggerAttackRelease(scareTones[Math.floor(Math.random() * 5)], "3n", "+0.05");
        }

        function init()
        {
            // init camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.z = 5;

            // init renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            // Post Processing
            // Creating Shader Passes
            renderPass = new THREE.RenderPass(scene, camera);
            rgbPass = new THREE.ShaderPass(THREE.RGBShiftShader);
            filmPass = new THREE.ShaderPass(THREE.FilmShader);
            copyPass = new THREE.ShaderPass(THREE.CopyShader);

            // set shader uniform
            filmPass.uniforms.grayscale.value = 0;
            
            // init Ambient Light
            var light = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(light);
            
            // init Point Light (pointing downwardly at the text)
            var light2 = new THREE.PointLight(0xdddddd, 0.5);
            light2.position.y = 250;
            scene.add(light2);

            // -------init submitting bool--------
            // # gatekeeps user input submission #
            //  ----------------------------------
            submitting = false;
            
            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;

                camera.updateProjectionMatrix();
            })
        }

        var animate = function () {
            requestAnimationFrame( animate );

            render();
        }

        function render() {
            renderer.render(scene, camera);
        }
    
        init();
        animate();
    </script>

</body>
</html>